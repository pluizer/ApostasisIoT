* Apostasis and IoT
  
[[images/05.png]]

In this lesson you will learn how to connect Internet connected devices to the @postasis platform and to each other.

** Overview

[[images/06.png]]

** Preparing the device

   To get started with connecting to the _@postasis platform_ we must first prepare the device. This manual assumes you are using the ESP8266 compatible device. Other Internet-enabled Arduino’s or Arduino clones can be used but one must look up the documentation on how to get started oneself. A ESP8266 is recommended to keep the project and examples uniform and can be ordered quite cheaply. It has built-in Wi-Fi capabilities.

   The first step is to add NodeMCU support to de Arduino IDE which this manual assumes is already installed on your pc.
   
   * Open the Arduino IDE, click on File → Preferences and paste the url: http://arduino.esp8266.com/stable/package_esp8266com_index.json into the Additional Boards Manager Urls.
     
     [[images/01.png]]
     
   * Close the window. Click Tools → Board → Board Manager and search for esp8266 and install it.

     [[images/02.png]]

   At this point the Arduino IDE is able to upload code to boards with an ESP8266 chip. To enable it navigate to Tools → Boards and select the board you are using. Now we are ready to upload the ApostasisIoT firmware. To do so;
   
   * Navigate to https://github.com/pluizer/ApostasisIoT and download and open the ArduinoIoT.ino file in the Arduino IDE.
     
   The firmware will try to connect to a WiFi access point. We must supply it with the name and password:
   
   * Change the line "(wifi-connect \"SSID\" \"PASSWORD\")"; with your correct SSID and PASSWORD of an available Wi-Fi access-point.

   * Compile and upload the project [[images/03.png]]

   At this point the board is ready to connect to the _@postasis platform_.
   
** Live coding in Lisp

   [[images/04.png]]

   Normally we program an Arduino by writing Processing code in the IDE and then uploading it to the board. This takes some time and when exploring and playing with code this can get tedious. Luckily, after having uploaded the firmware in previous steps, the board now comes with the capability to be programmed while running in a language called Lisp (uLisp in this case). A simple way to do so is to make sure the board is connected to the computer and open the serial console with Ctrl+Shift+M.
   It is now possible to enter Lisp code and have it evaluated immediately. Go ahaid and enter "Hello world" in the console to see if it works.
   Lisp is an easy language to learn, here are the basics:
   
** Values and Functions
*** Values

    Clojure's _reader_ reads code, called an _expression_ and than returns its value. Reading expressions and than and returning its value is called; _evaluating_ that expression. The most simple expression possible are just _values_ which evaluate to them self.

    For example for numbers:

    ~12~ evaluates to ~12~ and ~3.14~ evaluates to ~3.14~.

*** Functions calls
    
    An expression can also stand between parentheses, this is called a list, for example:

    #+BEGIN_SRC lisp
    (+ 12 3.14)
    #+END_SRC
    
    When Lisp's reader encounters such an expression it considers the first item of the list to evaluate to a function (more on functions later). In the last example ~+~ evaluates to a function that returns the _sum_ of its _arguments_.
    
    Everything but the first item of a list are the arguments that go in that function. Arguments are the values that the functions takes to do its work. In this example to arguments for the function ~+~ are ~12~ and ~3.14~.

    This expression than evaluates to the sum of its arguments. So ~(+ 12 3.14)~ evaluates to ~15.34~. 
    
    These lists (where the first item of the list evaluates to a function and the rest to its arguments) are called _function calls_.

    If one of the items of such a _function call_ is itself a function call the last one is evaluated first. So for example:

    #+BEGIN_SRC lisp
    (+ (+ 2 3) 4)
    #+END_SRC
    is first evaluated to
    #+BEGIN_SRC lisp
    (+ 5 4)
    #+END_SRC
    and lastly to:
    #+BEGIN_SRC lisp
    9
    #+END_SRC

    another example:
    #+BEGIN_SRC lisp
    (+ (+ 2 (+ 1 1)) (+ 3 4))
    #+END_SRC
    becomes ...
    #+BEGIN_SRC lisp
    (+ (+ 2 2) 7)
    #+END_SRC
    becomes ...
    #+BEGIN_SRC lisp
    (+ 4 7) 
    #+END_SRC
    and finally becomes ...
    #+BEGIN_SRC lisp
    13
    #+END_SRC
    
**** Exercise

     Evaluate the following expressions by hand:

    #+BEGIN_SRC lisp
    (+ 1 2)
    #+END_SRC
    
    #+BEGIN_SRC lisp
    (+ (+ 2 3) 2)
    #+END_SRC
     
    #+BEGIN_SRC lisp
    (+ (+ 2 3) 2 (+ 2 2))
    #+END_SRC
    
*** Comments    

    Anywhere the reader encounters text preceded by one or more semicolons (~;~) anything following it until the end of the line will be ignored. This is used to add human readable comments to code. For example:

    #+BEGIN_SRC lisp
    (+ 2 3) ;; this part will be ignored
    #+END_SRC
    
    will still evaluate to ~5~.
    
*** Variables
**** Let expressions

    Variables can be bounded to symbols using ~let~. An example paints a thousand words:

    #+BEGIN_SRC lisp
    (let ((a 5) (+ a 3)))
    ;;     ^       ^
    ;;     |-------------- here the value 5 is bounded to the symbol: a
    ;;             |------ here, a, stands for, 5, so this coded becomes
    (+ 5 3)
    ;; which evaluates to
    8
    #+END_SRC
    
***** Exercise

      Evaluate the following expressions by hand:
      
      #+BEGIN_SRC lisp
      (let ((a 2)) a)
      ;; ???

      (let ((apple 12)) appel)
      ;; ???

      (let ((pear 222)) (+ pear pear))
      ;; ???
      #+END_SRC
    
**** Nesting _let expressions_
    
    A _let expression_ (which is how there are called) can contain other _let expressions_, this is called nesting. for example:


    #+BEGIN_SRC lisp
    (let ((a 5)) (let ((b 3)) (+ a b)))
    ;;     ^            ^        ^ ^
    ;;     |---------------------------- here a is bounded to 5
    ;;                  |--------------- and b is bounded to 3
    ;;                           |------ a, is 5 here
    ;;                             |---- and b is 3
    ;; so this code becomes
    (+ 5 3)
    ;; which still evaluates to
    8
    #+END_SRC

    the value that is to be bound can also be an expression, for example:

    #+BEGIN_SRC lisp
    (let ((a (+ 2 3))) (+ a a))
    ;; becomes
    (let ((a 5)) (+ a a))
    ;; becomes
    (+ a a)
    ;; becomes
    10
    #+END_SRC
    
    the value that is to be bound can also contain the symbol of a previously bound value:

    #+BEGIN_SRC lisp
    (let ((a (+ 2 3))) (let ((b (+ a a))) (+ a b)))
    ;; becomes
    (let ((a 5)) (let ((b (+ a a))) (+ a b)))
    ;; becomes
    (let ((b (+ 5 5))) (+ 5 b))
    ;; becomes
    (let ((b 10)) (+ 5 b))
    ;; becomes
    (+ 5 10)
    ;; becomes
    15
    #+END_SRC

***** Exercise

      Evaluate the following expressions by hand:
      
      #+BEGIN_SRC lisp
      (let ((a 1)) (let ((b 2)) (+ a b)))
      ;; ???
      
      (let ((a 1)) (let ((b (+ a 2))) (+ a b)))
      ;; ???

      (let ((a (+ 2 2))) (let ((b (+ a a))) (+ b b)))
      ;; ???
      #+END_SRC

**** Shadowing    

     When a nested let expressions contains a symbol that was already bound the this first binding will _shadow_ the first. That means that a symbol will evaluate to its most inner binding. The outer binding are not visible anymore. To show you:

     #+BEGIN_SRC lisp
     (let ((a 4)) (let ((a 3)) a))
     ;;     ^---------------------- a, does not exist here yet
     ;;                  |--------- here a, is sill bounded to 4
     ;;                        |--- here a is bounded to 4, it shadows the a bounded to 3.
     ;; so this expression becomes
     3
     #+END_SRC
     
     Some more examples ...
     #+BEGIN_SRC lisp
     (let ((a 3)) (let ((a a)) a))
     ;; becomes
     (let ((a 3)) a)
     ;; becomes
     3

     (let ((a 3)) (let ((a (+ a a))) a))
     ;; so,...
     (let ((a 3)) (let ((a (+ a a))) a))
     ;; becomes
     (let ((a (+ 3 3))) a)
     ;; becomes
     (let ((a 6)) a)
     ;; becomes
     6
     #+END_SRC
     
*TODO: Explain about setq and defun*

** Reading pins and sensors

   To read the value of a pin or sensor you use the built-in functions ~analogread~ and ~digitalread~. The first one reads the value of a sensor connected to a analog pin by measuring it's current. The second one either returns ~true~ if there is current running trough the pin or else ~false~ when there is none.

   For example, connect a button to the board at pin ~5~.

   *TODO: Create image on how to connect the button*

   If you run the function ~(digitalread 5)~ it should return ~false~ if you did not press the button in the mean time and ~true~ when the button was pressed.

** Connecting to @postasis

*** Reading values

   Now that you have some basics in Lisp it is time to make the connection to _@postasis_ The main way to connect to the _@postasis platform_ is by using the REST-api. The firmware uploaded to your board makes this very easy.
   The first step is to create a _key_ inside of the platform. How to do this is outside of the scope of this lesson, I like to refer to the _@postasis framework_ documentation to learn how to do this.
   Values can be written to a key and they can be read from a key. It is like a variable in Processing (and lisp) but it's state is shared between other projects and Arduino's connected to _@postasis_.

   * All keys inside _@postasis_ need a password. For demonstration purpouses a key has been created called ~button~ with the password ~1234567~. 

   To read values associated to keys we use the ~read-value~ function. It takes the name of the key as argument. For example, to read the value currently associated to the key ~button~ we'd use ~(read-value "button")~.

*** Writing values

    Values can be written to in the same way using the ~set-value~ function. To write a value we need to also supply the password. For example to _write_ a new value (in this case ~42~) to the key ~button~ we'd use ~(set-value "button" 42 "1234567")~.

*** Connecting it all together

    Using all this information it is time to connect a button to the _@postasis framework_ using this code
   
*** Connecting devices to the virtual space

    #+BEGIN_SRC lisp
    ;; Sets the key and password to use in the Apostasis Framework
    (defvar *key* "button")
    (defvar *password* "1234567")
    ;; Sets the pin the where the button is connected to on the Arduino
    (defvar *button-pin* 5)
    
    ;; Sets the button pin to be an input
    (pinmode *button-pin* nil)
    
    ;; Aux function for toggle-and-set
    (defun -toggle (v)
    (if (eq v 1) 0 1))
    
    ;; Switches the value of "button" between 0 and 1
    (defun toggle-and-set (v key password)
    (set-value *key* (-toggle v) *password*))
    
    ;; Keep running this loop
    (defun main-loop ()
    ;; Wait a tenth of a second
    (delay 100)
    ;; When button is pressed toggle the "button" value on the
    ;; Apostasis Framework
    (when (digitalread *button-pin*)
    (read-value *key* toggle-and-set))
    (main-loop))
    #+END_SRC
     
**** Via the REST API
     
     #+BEGIN_SRC csharp
     using System.Collections;
     using System.Collections.Generic;
     using UnityEngine;
     using Apostasis.Runtime;
     using UnityOSC;
     public class MyTestClass : ApostasisBehaviour{
     
         Light light;
     
         void Start() {
             light = gameObject.GetComponent<Light>();
             if (light == null) {
                 Debug.Log("light is null");
             }
         }
     
         public ApostasisGlobalVariableReader globalReader;
         public override void OnServerOscRecieved (OscMessage oscMessage) {
             float v = oscMessage.GetFloat(0);
             float i = (8.0f/1024.0f)*v;
             light.intensity = i;
             Debug.Log(i);
     
         }
     }
     #+END_SRC

**** Via the OSC API
     
*** Connecting devices together


